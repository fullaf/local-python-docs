<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pickle &#8212; Python object serialization &mdash; Python v3.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0 documentation" href="../index.html" />
    <link rel="up" title="Data Persistence" href="persistence.html" />
    <link rel="next" title="copyreg &#8212; Register pickle support functions" href="copyreg.html" />
    <link rel="prev" title="Data Persistence" href="persistence.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg &#8212; Register pickle support functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="Data Persistence"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li><li><a href="../index.html">Python v3.0 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" accesskey="U">Data Persistence</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-pickle">
<h1><tt class="xref docutils literal"><span class="pre">pickle</span></tt> &#8212; Python object serialization<a class="headerlink" href="#module-pickle" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-416"></span><p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module implements a fundamental, but powerful algorithm for
serializing and de-serializing a Python object structure.  &#8220;Pickling&#8221; is the
process whereby a Python object hierarchy is converted into a byte stream, and
&#8220;unpickling&#8221; is the inverse operation, whereby a byte stream is converted back
into an object hierarchy.  Pickling (and unpickling) is alternatively known as
&#8220;serialization&#8221;, &#8220;marshalling,&#8221; <a class="footnote-reference" href="#id5" id="id1">[1]</a> or &#8220;flattening&#8221;, however, to avoid
confusion, the terms used here are &#8220;pickling&#8221; and &#8220;unpickling&#8221;..</p>
<div class="section" id="relationship-to-other-python-modules">
<h2>Relationship to other Python modules<a class="headerlink" href="#relationship-to-other-python-modules" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module has an transparent optimizer (<tt class="xref docutils literal"><span class="pre">_pickle</span></tt>) written
in C.  It is used whenever available.  Otherwise the pure Python implementation is
used.</p>
<p>Python has a more primitive serialization module called <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a>, but in
general <tt class="xref docutils literal"><span class="pre">pickle</span></tt> should always be the preferred way to serialize Python
objects.  <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> exists primarily to support Python&#8217;s <tt class="docutils literal"><span class="pre">.pyc</span></tt>
files.</p>
<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module differs from <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> several significant ways:</p>
<ul>
<li><p class="first">The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module keeps track of the objects it has already serialized,
so that later references to the same object won&#8217;t be serialized again.
<a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> doesn&#8217;t do this.</p>
<p>This has implications both for recursive objects and object sharing.  Recursive
objects are objects that contain references to themselves.  These are not
handled by marshal, and in fact, attempting to marshal recursive objects will
crash your Python interpreter.  Object sharing happens when there are multiple
references to the same object in different places in the object hierarchy being
serialized.  <tt class="xref docutils literal"><span class="pre">pickle</span></tt> stores such objects only once, and ensures that all
other references point to the master copy.  Shared objects remain shared, which
can be very important for mutable objects.</p>
</li>
<li><p class="first"><a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> cannot be used to serialize user-defined classes and their
instances.  <tt class="xref docutils literal"><span class="pre">pickle</span></tt> can save and restore class instances transparently,
however the class definition must be importable and live in the same module as
when the object was stored.</p>
</li>
<li><p class="first">The <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> serialization format is not guaranteed to be portable
across Python versions.  Because its primary job in life is to support
<tt class="docutils literal"><span class="pre">.pyc</span></tt> files, the Python implementers reserve the right to change the
serialization format in non-backwards compatible ways should the need arise.
The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> serialization format is guaranteed to be backwards compatible
across Python releases.</p>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module is not intended to be secure against erroneous or
maliciously constructed data.  Never unpickle data received from an untrusted or
unauthenticated source.</p>
</div>
<p>Note that serialization is a more primitive notion than persistence; although
<tt class="xref docutils literal"><span class="pre">pickle</span></tt> reads and writes file objects, it does not handle the issue of
naming persistent objects, nor the (even more complicated) issue of concurrent
access to persistent objects.  The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module can transform a complex
object into a byte stream and it can transform the byte stream into an object
with the same internal structure.  Perhaps the most obvious thing to do with
these byte streams is to write them onto a file, but it is also conceivable to
send them across a network or store them in a database.  The module
<a title="Python object persistence." class="reference external" href="shelve.html"><tt class="xref docutils literal"><span class="pre">shelve</span></tt></a> provides a simple interface to pickle and unpickle objects on
DBM-style database files.</p>
</div>
<div class="section" id="data-stream-format">
<h2>Data stream format<a class="headerlink" href="#data-stream-format" title="Permalink to this headline">¶</a></h2>
<p id="index-417">The data format used by <tt class="xref docutils literal"><span class="pre">pickle</span></tt> is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards such as
XDR (which can&#8217;t represent pointer sharing); however it means that non-Python
programs may not be able to reconstruct pickled Python objects.</p>
<p>By default, the <tt class="xref docutils literal"><span class="pre">pickle</span></tt> data format uses a compact binary representation.
The module <a title="Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions." class="reference external" href="pickletools.html"><tt class="xref docutils literal"><span class="pre">pickletools</span></tt></a> contains tools for analyzing data streams
generated by <tt class="xref docutils literal"><span class="pre">pickle</span></tt>.</p>
<p>There are currently 4 different protocols which can be used for pickling.</p>
<ul class="simple">
<li>Protocol version 0 is the original ASCII protocol and is backwards compatible
with earlier versions of Python.</li>
<li>Protocol version 1 is the old binary format which is also compatible with
earlier versions of Python.</li>
<li>Protocol version 2 was introduced in Python 2.3.  It provides much more
efficient pickling of <a class="reference external" href="../glossary.html#term-new-style-class"><em class="xref">new-style class</em></a>es.</li>
<li>Protocol version 3 was added in Python 3.0.  It has explicit support for
bytes and cannot be unpickled by Python 2.x pickle modules.  This is
the current recommended protocol, use it whenever it is possible.</li>
</ul>
<p>Refer to <span class="target" id="index-418"></span><a class="reference external" href="http://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> for information about improvements brought by
protocol 2.  See <a title="Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions." class="reference external" href="pickletools.html"><tt class="xref docutils literal"><span class="pre">pickletools</span></tt></a>&#8216;s source code for extensive
comments about opcodes used by pickle protocols.</p>
</div>
<div class="section" id="module-interface">
<h2>Module Interface<a class="headerlink" href="#module-interface" title="Permalink to this headline">¶</a></h2>
<p>To serialize an object hierarchy, you first create a pickler, then you call the
pickler&#8217;s <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> method.  To de-serialize a data stream, you first create
an unpickler, then you call the unpickler&#8217;s <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> method.  The
<tt class="xref docutils literal"><span class="pre">pickle</span></tt> module provides the following constant:</p>
<dl class="data">
<dt id="pickle.HIGHEST_PROTOCOL">
<!--[pickle.HIGHEST_PROTOCOL]--><tt class="descclassname">pickle.</tt><tt class="descname">HIGHEST_PROTOCOL</tt><a class="headerlink" href="#pickle.HIGHEST_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd>The highest protocol version available.  This value can be passed as a
<em>protocol</em> value.</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Be sure to always open pickle files created with protocols &gt;= 1 in binary mode.
For the old ASCII-based pickle protocol 0 you can use either text mode or binary
mode as long as you stay consistent.</p>
<p class="last">A pickle file written with protocol 0 in binary mode will contain lone linefeeds
as line terminators and therefore will look &#8220;funny&#8221; when viewed in Notepad or
other editors which do not support this format.</p>
</div>
<dl class="data">
<dt id="pickle.DEFAULT_PROTOCOL">
<!--[pickle.DEFAULT_PROTOCOL]--><tt class="descclassname">pickle.</tt><tt class="descname">DEFAULT_PROTOCOL</tt><a class="headerlink" href="#pickle.DEFAULT_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd>The default protocol used for pickling.  May be less than HIGHEST_PROTOCOL.
Currently the default protocol is 3; a backward-incompatible protocol
designed for Python 3.0.</dd></dl>

<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module provides the following functions to make the pickling
process more convenient:</p>
<dl class="function">
<dt id="pickle.dump">
<!--[pickle.dump]--><tt class="descclassname">pickle.</tt><tt class="descname">dump</tt><big>(</big><em>obj</em>, <em>file</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pickled representation of <em>obj</em> to the open file object <em>file</em>.  This
is equivalent to <tt class="docutils literal"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></tt>.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
<p>The <em>file</em> argument must have a write() method that accepts a single bytes
argument.  It can thus be a file object opened for binary writing, a
io.BytesIO instance, or any other custom object that meets this interface.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.dumps">
<!--[pickle.dumps]--><tt class="descclassname">pickle.</tt><tt class="descname">dumps</tt><big>(</big><em>obj</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pickled representation of the object as a <a title="bytes" class="reference external" href="functions.html#bytes"><tt class="xref docutils literal"><span class="pre">bytes</span></tt></a>
object, instead of writing it to a file.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.load">
<!--[pickle.load]--><tt class="descclassname">pickle.</tt><tt class="descname">load</tt><big>(</big><em>file</em><span class="optional">[</span>, <em>*</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object representation from the open file object <em>file</em> and
return the reconstituted object hierarchy specified therein.  This is
equivalent to <tt class="docutils literal"><span class="pre">Unpickler(file).load()</span></tt>.</p>
<p>The protocol version of the pickle is detected automatically, so no protocol
argument is needed.  Bytes past the pickled object&#8217;s representation are
ignored.</p>
<p>The argument <em>file</em> must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus <em>file</em> can be a binary file object opened
for reading, a BytesIO object, or any other custom object that meets this
interface.</p>
<p>Optional keyword arguments are encoding and errors, which are used to decode
8-bit string instances pickled by Python 2.x.  These default to &#8216;ASCII&#8217; and
&#8216;strict&#8217;, respectively.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.loads">
<!--[pickle.loads]--><tt class="descclassname">pickle.</tt><tt class="descname">loads</tt><big>(</big><em>bytes_object</em><span class="optional">[</span>, <em>*</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object hierarchy from a <a title="bytes" class="reference external" href="functions.html#bytes"><tt class="xref docutils literal"><span class="pre">bytes</span></tt></a> object and return the
reconstituted object hierarchy specified therein</p>
<p>The protocol version of the pickle is detected automatically, so no protocol
argument is needed.  Bytes past the pickled object&#8217;s representation are
ignored.</p>
<p>Optional keyword arguments are encoding and errors, which are used to decode
8-bit string instances pickled by Python 2.x.  These default to &#8216;ASCII&#8217; and
&#8216;strict&#8217;, respectively.</p>
</dd></dl>

<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module defines three exceptions:</p>
<dl class="exception">
<dt id="pickle.PickleError">
<!--[pickle.PickleError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">PickleError</tt><a class="headerlink" href="#pickle.PickleError" title="Permalink to this definition">¶</a></dt>
<dd>Common base class for the other pickling exceptions.  It inherits
<a title="exceptions.Exception" class="reference external" href="exceptions.html#exceptions.Exception"><tt class="xref docutils literal"><span class="pre">Exception</span></tt></a>.</dd></dl>

<dl class="exception">
<dt id="pickle.PicklingError">
<!--[pickle.PicklingError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">PicklingError</tt><a class="headerlink" href="#pickle.PicklingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error raised when an unpicklable object is encountered by <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a>.
It inherits <a title="pickle.PickleError" class="reference internal" href="#pickle.PickleError"><tt class="xref docutils literal"><span class="pre">PickleError</span></tt></a>.</p>
<p>Refer to <a class="reference internal" href="#pickle-picklable"><em>What can be pickled and unpickled?</em></a> to learn what kinds of objects can be
pickled.</p>
</dd></dl>

<dl class="exception">
<dt id="pickle.UnpicklingError">
<!--[pickle.UnpicklingError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">UnpicklingError</tt><a class="headerlink" href="#pickle.UnpicklingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error raised when there a problem unpickling an object, such as a data
corruption or a security violation.  It inherits <a title="pickle.PickleError" class="reference internal" href="#pickle.PickleError"><tt class="xref docutils literal"><span class="pre">PickleError</span></tt></a>.</p>
<p>Note that other exceptions may also be raised during unpickling, including
(but not necessarily limited to) AttributeError, EOFError, ImportError, and
IndexError.</p>
</dd></dl>

<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module exports two classes, <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> and
<a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a>:</p>
<dl class="class">
<dt id="pickle.Pickler">
<!--[pickle.Pickler]-->class <tt class="descclassname">pickle.</tt><tt class="descname">Pickler</tt><big>(</big><em>file</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.Pickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a binary file for writing a pickle data stream.</p>
<p>The optional <em>protocol</em> argument tells the pickler to use the given protocol;
supported protocols are 0, 1, 2, 3.  The default protocol is 3; a
backward-incompatible protocol designed for Python 3.0.</p>
<p>Specifying a negative protocol version selects the highest protocol version
supported.  The higher the protocol used, the more recent the version of
Python needed to read the pickle produced.</p>
<p>The <em>file</em> argument must have a write() method that accepts a single bytes
argument.  It can thus be a file object opened for binary writing, a
io.BytesIO instance, or any other custom object that meets this interface.</p>
<dl class="method">
<dt id="pickle.Pickler.dump">
<!--[pickle.Pickler.dump]--><tt class="descname">dump</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pickle.Pickler.dump" title="Permalink to this definition">¶</a></dt>
<dd>Write a pickled representation of <em>obj</em> to the open file object given in
the constructor.</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.persistent_id">
<!--[pickle.Pickler.persistent_id]--><tt class="descname">persistent_id</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pickle.Pickler.persistent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing by default.  This exists so a subclass can override it.</p>
<p>If <a title="pickle.Pickler.persistent_id" class="reference internal" href="#pickle.Pickler.persistent_id"><tt class="xref docutils literal"><span class="pre">persistent_id()</span></tt></a> returns <tt class="xref docutils literal"><span class="pre">None</span></tt>, <em>obj</em> is pickled as usual.  Any
other value causes <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> to emit the returned value as a
persistent ID for <em>obj</em>.  The meaning of this persistent ID should be
defined by <a title="pickle.Unpickler.persistent_load" class="reference internal" href="#pickle.Unpickler.persistent_load"><tt class="xref docutils literal"><span class="pre">Unpickler.persistent_load()</span></tt></a>.  Note that the value
returned by <a title="pickle.Pickler.persistent_id" class="reference internal" href="#pickle.Pickler.persistent_id"><tt class="xref docutils literal"><span class="pre">persistent_id()</span></tt></a> cannot itself have a persistent ID.</p>
<p>See <a class="reference internal" href="#pickle-persistent"><em>Persistence of External Objects</em></a> for details and examples of uses.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.clear_memo">
<!--[pickle.Pickler.clear_memo]--><tt class="descname">clear_memo</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Pickler.clear_memo" title="Permalink to this definition">¶</a></dt>
<dd>Deprecated.  Use the <tt class="xref docutils literal"><span class="pre">clear()</span></tt> method on <a title="pickle.Pickler.memo" class="reference internal" href="#pickle.Pickler.memo"><tt class="xref docutils literal"><span class="pre">memo</span></tt></a>, instead.
Clear the pickler&#8217;s memo, useful when reusing picklers.</dd></dl>

<dl class="attribute">
<dt id="pickle.Pickler.fast">
<!--[pickle.Pickler.fast]--><tt class="descname">fast</tt><a class="headerlink" href="#pickle.Pickler.fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Enable fast mode if set to a true value.  The fast mode
disables the usage of memo, therefore speeding the pickling process by not
generating superfluous PUT opcodes.  It should not be used with
self-referential objects, doing otherwise will cause <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> to
recurse infinitely.</p>
<p>Use <a title="pickletools.optimize" class="reference external" href="pickletools.html#pickletools.optimize"><tt class="xref docutils literal"><span class="pre">pickletools.optimize()</span></tt></a> if you need more compact pickles.</p>
</dd></dl>

<dl class="attribute">
<dt id="pickle.Pickler.memo">
<!--[pickle.Pickler.memo]--><tt class="descname">memo</tt><a class="headerlink" href="#pickle.Pickler.memo" title="Permalink to this definition">¶</a></dt>
<dd>Dictionary holding previously pickled objects to allow shared or
recursive objects to pickled by reference as opposed to by value.</dd></dl>

</dd></dl>

<p>It is possible to make multiple calls to the <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> method of the same
<a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> instance.  These must then be matched to the same number of
calls to the <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> method of the corresponding <a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a>
instance.  If the same object is pickled by multiple <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> calls, the
<a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> will all yield references to the same object.</p>
<p>Please note, this is intended for pickling multiple objects without intervening
modifications to the objects or their parts.  If you modify an object and then
pickle it again using the same <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> instance, the object is not
pickled again &#8212; a reference to it is pickled and the <a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a> will
return the old value, not the modified one.</p>
<dl class="class">
<dt id="pickle.Unpickler">
<!--[pickle.Unpickler]-->class <tt class="descclassname">pickle.</tt><tt class="descname">Unpickler</tt><big>(</big><em>file</em><span class="optional">[</span>, <em>*</em>, <em>encoding=&quot;ASCII&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.Unpickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a binary file for reading a pickle data stream.</p>
<p>The protocol version of the pickle is detected automatically, so no
protocol argument is needed.</p>
<p>The argument <em>file</em> must have two methods, a read() method that takes an
integer argument, and a readline() method that requires no arguments.  Both
methods should return bytes.  Thus <em>file</em> can be a binary file object opened
for reading, a BytesIO object, or any other custom object that meets this
interface.</p>
<p>Optional keyword arguments are encoding and errors, which are used to decode
8-bit string instances pickled by Python 2.x.  These default to &#8216;ASCII&#8217; and
&#8216;strict&#8217;, respectively.</p>
<dl class="method">
<dt id="pickle.Unpickler.load">
<!--[pickle.Unpickler.load]--><tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Unpickler.load" title="Permalink to this definition">¶</a></dt>
<dd>Read a pickled object representation from the open file object given in
the constructor, and return the reconstituted object hierarchy specified
therein.  Bytes past the pickled object&#8217;s representation are ignored.</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.persistent_load">
<!--[pickle.Unpickler.persistent_load]--><tt class="descname">persistent_load</tt><big>(</big><em>pid</em><big>)</big><a class="headerlink" href="#pickle.Unpickler.persistent_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an <tt class="xref docutils literal"><span class="pre">UnpickingError</span></tt> by default.</p>
<p>If defined, <a title="pickle.Unpickler.persistent_load" class="reference internal" href="#pickle.Unpickler.persistent_load"><tt class="xref docutils literal"><span class="pre">persistent_load()</span></tt></a> should return the object specified by
the persistent ID <em>pid</em>.  If an invalid persistent ID is encountered, an
<tt class="xref docutils literal"><span class="pre">UnpickingError</span></tt> should be raised.</p>
<p>See <a class="reference internal" href="#pickle-persistent"><em>Persistence of External Objects</em></a> for details and examples of uses.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.find_class">
<!--[pickle.Unpickler.find_class]--><tt class="descname">find_class</tt><big>(</big><em>module</em>, <em>name</em><big>)</big><a class="headerlink" href="#pickle.Unpickler.find_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Import <em>module</em> if necessary and return the object called <em>name</em> from it,
where the <em>module</em> and <em>name</em> arguments are <a title="str" class="reference external" href="functions.html#str"><tt class="xref docutils literal"><span class="pre">str</span></tt></a> objects.  Note,
unlike its name suggests, <a title="pickle.Unpickler.find_class" class="reference internal" href="#pickle.Unpickler.find_class"><tt class="xref docutils literal"><span class="pre">find_class()</span></tt></a> is also used for finding
functions.</p>
<p>Subclasses may override this to gain control over what type of objects and
how they can be loaded, potentially reducing security risks. Refer to
<a class="reference internal" href="#pickle-restrict"><em>Restricting Globals</em></a> for details.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-can-be-pickled-and-unpickled">
<span id="pickle-picklable"></span><h2>What can be pickled and unpickled?<a class="headerlink" href="#what-can-be-pickled-and-unpickled" title="Permalink to this headline">¶</a></h2>
<p>The following types can be pickled:</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="xref docutils literal"><span class="pre">True</span></tt>, and <tt class="xref docutils literal"><span class="pre">False</span></tt></li>
<li>integers, floating point numbers, complex numbers</li>
<li>strings, bytes, bytearrays</li>
<li>tuples, lists, sets, and dictionaries containing only picklable objects</li>
<li>functions defined at the top level of a module</li>
<li>built-in functions defined at the top level of a module</li>
<li>classes that are defined at the top level of a module</li>
<li>instances of such classes whose <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> or <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> is
picklable  (see section <a class="reference internal" href="#pickle-inst"><em>Pickling Class Instances</em></a> for details)</li>
</ul>
<p>Attempts to pickle unpicklable objects will raise the <a title="pickle.PicklingError" class="reference internal" href="#pickle.PicklingError"><tt class="xref docutils literal"><span class="pre">PicklingError</span></tt></a>
exception; when this happens, an unspecified number of bytes may have already
been written to the underlying file.  Trying to pickle a highly recursive data
structure may exceed the maximum recursion depth, a <a title="exceptions.RuntimeError" class="reference external" href="exceptions.html#exceptions.RuntimeError"><tt class="xref docutils literal"><span class="pre">RuntimeError</span></tt></a> will be
raised in this case.  You can carefully raise this limit with
<a title="sys.setrecursionlimit" class="reference external" href="sys.html#sys.setrecursionlimit"><tt class="xref docutils literal"><span class="pre">sys.setrecursionlimit()</span></tt></a>.</p>
<p>Note that functions (built-in and user-defined) are pickled by &#8220;fully qualified&#8221;
name reference, not by value.  This means that only the function name is
pickled, along with the name of module the function is defined in.  Neither the
function&#8217;s code, nor any of its function attributes are pickled.  Thus the
defining module must be importable in the unpickling environment, and the module
must contain the named object, otherwise an exception will be raised. <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>Similarly, classes are pickled by named reference, so the same restrictions in
the unpickling environment apply.  Note that none of the class&#8217;s code or data is
pickled, so in the following example the class attribute <tt class="docutils literal"><span class="pre">attr</span></tt> is not
restored in the unpickling environment:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s">&#39;A class attribute&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
<p>These restrictions are why picklable functions and classes must be defined in
the top level of a module.</p>
<p>Similarly, when class instances are pickled, their class&#8217;s code and data are not
pickled along with them.  Only the instance data are pickled.  This is done on
purpose, so you can fix bugs in a class or add methods to the class and still
load objects that were created with an earlier version of the class.  If you
plan to have long-lived objects that will see many versions of a class, it may
be worthwhile to put a version number in the objects so that suitable
conversions can be made by the class&#8217;s <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> method.</p>
</div>
<div class="section" id="pickling-class-instances">
<span id="pickle-inst"></span><h2>Pickling Class Instances<a class="headerlink" href="#pickling-class-instances" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the general mechanisms available to you to define,
customize, and control how class instances are pickled and unpickled.</p>
<p>In most cases, no additional code is needed to make instances picklable.  By
default, pickle will retrieve the class and the attributes of an instance via
introspection. When a class instance is unpickled, its <a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> method
is usually <em>not</em> invoked.  The default behaviour first creates an uninitialized
instance and then restores the saved attributes.  The following code shows an
implementation of this behaviour:</p>
<pre>def save(obj):
    return (obj.__class__, obj.__dict__)

def load(cls, attributes):
    obj = cls.__new__(cls)
    obj.__dict__.update(attributes)
    return obj</pre>
<p id="index-419">Classes can alter the default behaviour by providing one or severals special
methods.  In protocol 2 and newer, classes that implements the
<tt class="xref docutils literal"><span class="pre">__getnewargs__()</span></tt> method can dictate the values passed to the
<a title="object.__new__" class="reference external" href="../reference/datamodel.html#object.__new__"><tt class="xref docutils literal"><span class="pre">__new__()</span></tt></a> method upon unpickling.  This is often needed for classes
whose <a title="object.__new__" class="reference external" href="../reference/datamodel.html#object.__new__"><tt class="xref docutils literal"><span class="pre">__new__()</span></tt></a> method requires arguments.</p>
<p id="index-420">Classes can further influence how their instances are pickled; if the class
defines the method <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt>, it is called and the returned object is
pickled as the contents for the instance, instead of the contents of the
instance&#8217;s dictionary.  If the <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> method is absent, the
instance&#8217;s <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> is pickled as usual.</p>
<p id="index-421">Upon unpickling, if the class defines <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>, it is called with
the unpickled state.  In that case, there is no requirement for the state object
to be a dictionary. Otherwise, the pickled state must be a dictionary and its
items are assigned to the new instance&#8217;s dictionary.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> returns a false value, the <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>
method will not be called.</p>
</div>
<p>Refer to the section <a class="reference internal" href="#pickle-state"><em>Handling Stateful Objects</em></a> for more information about how to use
the methods <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> and <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>.</p>
<p id="index-422">As we shall see, pickle does not use directly the methods described above.  In
fact, these methods are part of the copy protocol which implements the
<tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> special method.  The copy protocol provides a unified
interface for retrieving the data necessary for pickling and copying
objects. <a class="footnote-reference" href="#id7" id="id3">[3]</a></p>
<p>Although powerful, implementing <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> directly in your classes is
error prone.  For this reason, class designers should use the high-level
interface (i.e., <tt class="xref docutils literal"><span class="pre">__getnewargs__()</span></tt>, <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> and
<tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>) whenever possible.  We will show however cases where using
<tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> is the only option or leads to more efficient pickling or
both.</p>
<p>The interface is currently defined as follow. The <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> method
takes no argument and shall return either a string or preferably a tuple (the
returned object is often refered as the &#8220;reduce value&#8221;).</p>
<p>If a string is returned, the string should be interpreted as the name of a
global variable.  It should be the object&#8217;s local name relative to its module;
the pickle module searches the module namespace to determine the object&#8217;s
module.  This behaviour is typically useful for singletons.</p>
<p>When a tuple is returned, it must be between two and five items long.  Optional
items can either be omitted, or <tt class="xref docutils literal"><span class="pre">None</span></tt> can be provided as their value.  The
semantics of each item are in order:</p>
<ul class="simple">
<li>A callable object that will be called to create the initial version of the
object.</li>
<li>A tuple of arguments for the callable object. An empty tuple must be given if
the callable does not accept any argument.</li>
<li>Optionally, the object&#8217;s state, which will be passed to the object&#8217;s
<tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> method as previously described.  If the object has no
such method then, the value must be a dictionary and it will be added to the
object&#8217;s <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> attribute.</li>
<li>Optionally, an iterator (and not a sequence) yielding successive items.  These
items will be appended to the object either using <tt class="docutils literal"><span class="pre">obj.append(item)</span></tt> or, in
batch, using <tt class="docutils literal"><span class="pre">obj.extend(list_of_items)</span></tt>.  This is primarily used for list
subclasses, but may be used by other classes as long as they have
<tt class="xref docutils literal"><span class="pre">append()</span></tt> and <tt class="xref docutils literal"><span class="pre">extend()</span></tt> methods with the appropriate signature.
(Whether <tt class="xref docutils literal"><span class="pre">append()</span></tt> or <tt class="xref docutils literal"><span class="pre">extend()</span></tt> is used depends on which pickle
protocol version is used as well as the number of items to append, so both
must be supported.)</li>
<li>Optionally, an iterator (not a sequence) yielding successive key-value pairs.
These items will be stored to the object using <tt class="docutils literal"><span class="pre">obj[key]</span> <span class="pre">=</span> <span class="pre">value</span></tt>.  This is
primarily used for dictionary subclasses, but may be used by other classes as
long as they implement <a title="object.__setitem__" class="reference external" href="../reference/datamodel.html#object.__setitem__"><tt class="xref docutils literal"><span class="pre">__setitem__()</span></tt></a>.</li>
</ul>
<p id="index-423">Alternatively, a <tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt> method may be defined.  The only
difference is this method should take a single integer argument, the protocol
version.  When defined, pickle will prefer it over the <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt>
method.  In addition, <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> automatically becomes a synonym for the
extended version.  The main use for this method is to provide
backwards-compatible reduce values for older Python releases.</p>
<div class="section" id="persistence-of-external-objects">
<span id="pickle-persistent"></span><h3>Persistence of External Objects<a class="headerlink" href="#persistence-of-external-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-424">For the benefit of object persistence, the <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a persistent ID, which should be either a string of
alphanumeric characters (for protocol 0) <a class="footnote-reference" href="#id8" id="id4">[4]</a> or just an arbitrary object (for
any newer protocol).</p>
<p>The resolution of such persistent IDs is not defined by the <tt class="xref docutils literal"><span class="pre">pickle</span></tt>
module; it will delegate this resolution to the user defined methods on the
pickler and unpickler, <tt class="xref docutils literal"><span class="pre">persistent_id()</span></tt> and <tt class="xref docutils literal"><span class="pre">persistent_load()</span></tt>
respectively.</p>
<p>To pickle objects that have an external persistent id, the pickler must have a
custom <tt class="xref docutils literal"><span class="pre">persistent_id()</span></tt> method that takes an object as an argument and
returns either <tt class="xref docutils literal"><span class="pre">None</span></tt> or the persistent id for that object.  When <tt class="xref docutils literal"><span class="pre">None</span></tt> is
returned, the pickler simply pickles the object as normal.  When a persistent ID
string is returned, the pickler will pickle that object, along with a marker so
that the unpickler will recognize it as a persistent ID.</p>
<p>To unpickle external objects, the unpickler must have a custom
<tt class="xref docutils literal"><span class="pre">persistent_load()</span></tt> method that takes a persistent ID object and returns the
referenced object.</p>
<p>Here is a comprehensive example presenting how persistent ID can be used to
pickle external objects by reference.</p>
<div class="highlight"><pre><span class="c"># Simple example presenting how persistent ID can be used to pickle</span>
<span class="c"># external objects by reference.</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c"># Simple class representing a record in our database.</span>
<span class="n">MemoRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="s">&quot;key, task&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">persistent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c"># Instead of pickling MemoRecord as a regular class instance, we emit a</span>
        <span class="c"># persistent ID.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MemoRecord</span><span class="p">):</span>
            <span class="c"># Here, our persistent ID is simply a tuple, containing a tag and a</span>
            <span class="c"># key, which refers to a specific record in the database.</span>
            <span class="k">return</span> <span class="p">(</span><span class="s">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If obj does not have a persistent ID, return None. This means obj</span>
            <span class="c"># needs to be pickled as usual.</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">DBUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">persistent_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c"># This method is invoked whenever a persistent ID is encountered.</span>
        <span class="c"># Here, pid is the tuple returned by DBPickler.</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">type_tag</span><span class="p">,</span> <span class="n">key_id</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="k">if</span> <span class="n">type_tag</span> <span class="o">==</span> <span class="s">&quot;MemoRecord&quot;</span><span class="p">:</span>
            <span class="c"># Fetch the referenced record from the database and return it.</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;SELECT * FROM memos WHERE key=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key_id</span><span class="p">),))</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Always raises an error if you cannot return the correct object.</span>
            <span class="c"># Otherwise, the unpickler will think None is the object referenced</span>
            <span class="c"># by the persistent ID.</span>
            <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s">&quot;unsupported persistent object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">io</span><span class="o">,</span> <span class="nn">pprint</span>

    <span class="c"># Initialize and populate our database.</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;:memory:&quot;</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)&quot;</span><span class="p">)</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&#39;give food to fish&#39;</span><span class="p">,</span>
        <span class="s">&#39;prepare group meeting&#39;</span><span class="p">,</span>
        <span class="s">&#39;fight with a zebra&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;INSERT INTO memos VALUES(NULL, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

    <span class="c"># Fetch the records to be pickled.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;SELECT * FROM memos&quot;</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="p">[</span><span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">]</span>
    <span class="c"># Save the records using our custom DBPickler.</span>
    <span class="nb">file</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">DBPickler</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Pickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="c"># Update a record, just for good measure.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;UPDATE memos SET task=&#39;learn italian&#39; WHERE key=1&quot;</span><span class="p">)</span>

    <span class="c"># Load the records from the pickle data stream.</span>
    <span class="nb">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="n">DBUnpickler</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Unpickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="handling-stateful-objects">
<span id="pickle-state"></span><h3>Handling Stateful Objects<a class="headerlink" href="#handling-stateful-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-425">Here&#8217;s an example that shows how to modify pickling behavior for a class.
The <tt class="xref docutils literal"><span class="pre">TextReader</span></tt> class opens a text file, and returns the line number and
line contents each time its <tt class="xref docutils literal"><span class="pre">readline()</span></tt> method is called. If a
<tt class="xref docutils literal"><span class="pre">TextReader</span></tt> instance is pickled, all attributes <em>except</em> the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> and
<tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> methods are used to implement this behavior.</p>
<pre>class TextReader:
    """Print and number lines in a text file."""

    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename)
        self.lineno = 0

    def readline(self):
        self.lineno += 1
        line = self.file.readline()
        if not line:
            return None
        if line.endswith("\n"):
            line = line[:-1]
        return "%i: %s" % (self.lineno, line)

    def __getstate__(self):
        # Copy the object's state from self.__dict__ which contains
        # all our instance attributes. Always use the dict.copy()
        # method to avoid modifying the original state.
        state = self.__dict__.copy()
        # Remove the unpicklable entries.
        del state['file']
        return state

    def __setstate__(self, state):
        # Restore instance attributes (i.e., filename and lineno).
        self.__dict__.update(state)
        # Restore the previously opened file's state. To do so, we need to
        # reopen it and read from it until the line count is restored.
        file = open(self.filename)
        for _ in range(self.lineno):
            file.readline()
        # Finally, save the file.
        self.file = file</pre>
<p>A sample usage might be something like this:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">TextReader</span><span class="p">(</span><span class="s">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: Hello world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: I am line number two.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: Goodbye!&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="restricting-globals">
<span id="pickle-restrict"></span><h2>Restricting Globals<a class="headerlink" href="#restricting-globals" title="Permalink to this headline">¶</a></h2>
<p id="index-426">By default, unpickling will import any class or function that it finds in the
pickle data.  For many applications, this behaviour is unacceptable as it
permits the unpickler to import and invoke arbitrary code.  Just consider what
this hand-crafted pickle data stream does when loaded:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;cos</span><span class="se">\n</span><span class="s">system</span><span class="se">\n</span><span class="s">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s">tR.&quot;</span><span class="p">)</span>
<span class="go">hello world</span>
<span class="go">0</span>
</pre></div>
<p>In this example, the unpickler imports the <a title="os.system" class="reference external" href="os.html#os.system"><tt class="xref docutils literal"><span class="pre">os.system()</span></tt></a> function and then
apply the string argument &#8220;echo hello world&#8221;.  Although this example is
inoffensive, it is not difficult to imagine one that could damage your system.</p>
<p>For this reason, you may want to control what gets unpickled by customizing
<a title="pickle.Unpickler.find_class" class="reference internal" href="#pickle.Unpickler.find_class"><tt class="xref docutils literal"><span class="pre">Unpickler.find_class()</span></tt></a>.  Unlike its name suggests, <tt class="xref docutils literal"><span class="pre">find_class()</span></tt> is
called whenever a global (i.e., a class or a function) is requested.  Thus it is
possible to either forbid completely globals or restrict them to a safe subset.</p>
<p>Here is an example of an unpickler allowing only few safe classes from the
<a title="The module that provides the built-in namespace." class="reference external" href="builtins.html"><tt class="xref docutils literal"><span class="pre">builtins</span></tt></a> module to be loaded:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;range&#39;</span><span class="p">,</span>
    <span class="s">&#39;complex&#39;</span><span class="p">,</span>
    <span class="s">&#39;set&#39;</span><span class="p">,</span>
    <span class="s">&#39;frozenset&#39;</span><span class="p">,</span>
    <span class="s">&#39;slice&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c"># Only allow safe classes from builtins.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s">&quot;builtins&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c"># Forbid everything else.</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s">&quot;global &#39;%s.%s&#39; is forbidden&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
<p>A sample usage of our unpickler working has intended:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mf">15</span><span class="p">)]))</span>
<span class="go">[1, 2, range(0, 15)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;cos</span><span class="se">\n</span><span class="s">system</span><span class="se">\n</span><span class="s">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s">tR.&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">pickle.UnpicklingError</span>: <span class="n-Identifier">global &#39;os.system&#39; is forbidden</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;cbuiltins</span><span class="se">\n</span><span class="s">eval</span><span class="se">\n</span><span class="s">&#39;</span>
<span class="gp">... </span>                 <span class="n">b</span><span class="s">&#39;(S</span><span class="se">\&#39;</span><span class="s">getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;</span>
<span class="gp">... </span>                 <span class="n">b</span><span class="s">&#39;(&quot;echo hello world&quot;)</span><span class="se">\&#39;\n</span><span class="s">tR.&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">pickle.UnpicklingError</span>: <span class="n-Identifier">global &#39;builtins.eval&#39; is forbidden</span>
</pre></div>
<p>As our examples shows, you have to be careful with what you allow to be
unpickled.  Therefore if security is a concern, you may want to consider
alternatives such as the marshalling API in <a title="XML-RPC client access." class="reference external" href="xmlrpc.client.html"><tt class="xref docutils literal"><span class="pre">xmlrpc.client</span></tt></a> or third-party
solutions.</p>
</div>
<div class="section" id="example">
<span id="pickle-example"></span><h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>For the simplest code, use the <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> and <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> functions.  Note
that a self-referencing list is pickled and restored correctly.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">data1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">],</span>
         <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;string using Unicode features </span><span class="se">\u0394</span><span class="s">&quot;</span><span class="p">),</span>
         <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="k">None</span><span class="p">}</span>

<span class="n">selfref_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">selfref_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>

<span class="c"># Pickle dictionary using protocol 2.</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c"># Pickle the list using the highest protocol available.</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>The following example reads the resulting pickled data.  When reading a
pickle-containing file, you should open the file in binary mode because you
can&#8217;t be sure if the ASCII or binary format was used.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">pprint</span><span class="o">,</span> <span class="nn">pickle</span>

<span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>

<span class="n">data1</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>

<span class="n">data2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

<span class="n">pkl_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Module <a title="Register pickle support functions." class="reference external" href="copyreg.html"><tt class="xref docutils literal"><span class="pre">copyreg</span></tt></a></dt>
<dd>Pickle interface constructor registration for extension types.</dd>
<dt>Module <a title="Python object persistence." class="reference external" href="shelve.html"><tt class="xref docutils literal"><span class="pre">shelve</span></tt></a></dt>
<dd>Indexed databases of objects; uses <tt class="xref docutils literal"><span class="pre">pickle</span></tt>.</dd>
<dt>Module <a title="Shallow and deep copy operations." class="reference external" href="copy.html"><tt class="xref docutils literal"><span class="pre">copy</span></tt></a></dt>
<dd>Shallow and deep object copying.</dd>
<dt>Module <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a></dt>
<dd>High-performance serialization of built-in types.</dd>
</dl>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Don&#8217;t confuse this with the <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> module</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The exception raised will likely be an <a title="exceptions.ImportError" class="reference external" href="exceptions.html#exceptions.ImportError"><tt class="xref docutils literal"><span class="pre">ImportError</span></tt></a> or an
<a title="exceptions.AttributeError" class="reference external" href="exceptions.html#exceptions.AttributeError"><tt class="xref docutils literal"><span class="pre">AttributeError</span></tt></a> but it could be something else.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The <a title="Shallow and deep copy operations." class="reference external" href="copy.html"><tt class="xref docutils literal"><span class="pre">copy</span></tt></a> module uses this protocol for shallow and deep copying
operations.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>The limitation on alphanumeric characters is due to the fact
the persistent IDs, in protocol 0, are delimited by the newline
character.  Therefore if any kind of newline characters occurs in
persistent IDs, the resulting pickle will become unreadable.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">pickle</span></tt> &#8212; Python object serialization</a><ul>
<li><a class="reference external" href="#relationship-to-other-python-modules">Relationship to other Python modules</a></li>
<li><a class="reference external" href="#data-stream-format">Data stream format</a></li>
<li><a class="reference external" href="#module-interface">Module Interface</a></li>
<li><a class="reference external" href="#what-can-be-pickled-and-unpickled">What can be pickled and unpickled?</a></li>
<li><a class="reference external" href="#pickling-class-instances">Pickling Class Instances</a><ul>
<li><a class="reference external" href="#persistence-of-external-objects">Persistence of External Objects</a></li>
<li><a class="reference external" href="#handling-stateful-objects">Handling Stateful Objects</a></li>
</ul>
</li>
<li><a class="reference external" href="#restricting-globals">Restricting Globals</a></li>
<li><a class="reference external" href="#example">Example</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="persistence.html" title="previous chapter">Data Persistence</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="copyreg.html" title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">copyreg</span></tt> &#8212; Register <tt class="docutils literal docutils literal"><span class="pre">pickle</span></tt> support functions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/pickle.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg &#8212; Register pickle support functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="Data Persistence"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li><li><a href="../index.html">Python v3.0 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" accesskey="U">Data Persistence</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Dec 04, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>